网络空间安全学院 2020级4班 陈思宇 202000460119
=
**注：本实验并不在课件的project要求中，为作者之前的计算机系统原理实验报告中实验六(基础任务a——使用HLS在PYNQ-Z1上完成SM4算法的实现与优化)的实验报告部分截取。该实验由本README.md作者陈思宇所在的计算机系统原理小组成员共同完成。该课程小组组员为：陈思宇、潘天乐、高瑞凯、杨桢弘、燕长森。**

实验内容：
=
**完成SM4算法的实现与优化。**

实现部分如下：
-
**（1）我们先在主函数外列出S盒和一个求2的幂的函数；**

**（2）进行密钥拓展：**

我们设输入加密密钥为MK(MK0，MK1，MK2，MK3),输出轮密钥为RKi（i=0,1,…,30,31），中间数据为Ki（i=0,1,…,34,35），则密钥扩展算法可描述如下：

①	( K0，K1，K2，K3) = (MK0⊕FK0,  MK1⊕FK1，MK2⊕FK2， MK3⊕FK3)，代码如下图所示：
![图片1](https://user-images.githubusercontent.com/109191115/181287725-91d29427-ff70-44b2-9203-af99e9af6b27.png)

②	for i=0,1, . . . ,30,31，Do RK=Ki⊕T’(Ki+1，Ki+2，Ki+3，CKi) ，代码如下图所示：
![图片2](https://user-images.githubusercontent.com/109191115/181287819-72849a26-1c04-4282-a39c-154d41388ba1.png)

**（3）非线性变换：**
SM4的非线性变换τ是一种以字为单位的非线性代替变换。它由4个S盒并置构成。我们设输入字为A＝(a0，a1，a2，a3），输出字为B＝(b0，b1，b2，b3)，则我们可以得到如下等式：
B = τ (A) = (Sbox(a0)，Sbox(a1)，Sbox(a2)，Sbox(a3)) 
![图片3](https://user-images.githubusercontent.com/109191115/181289273-1c24ab5a-86ff-4bab-9ebb-9e71b9ca8d7a.png)

*（注：s=ck[i-4]）*

**（4）线性变换：**

线性变换部件L是以字为处理单位的线性变换部件，其输入输出都是32位的字。设L的输入为字B，输出为字C，则可以得到L’(B)=B⊕(B<<<13)⊕(B<<<23)，代码如下图所示：

![图片4](https://user-images.githubusercontent.com/109191115/181290071-202d20b7-5b20-4dff-aada-1a22741215f1.png)

**（5）加密算法：**

加密算法采用32轮迭代结构，每轮使用一个轮密钥。数据分组长度为128比特，密钥长度为128比特。我们设输入明文为(X0，X1，X2，X3)，一共四个字共128位。输入轮密钥为RKi（i＝0,1,…,31），共32个字。输出密文为（Y0，Y1，Y2，Y3），一共四个字共128位。则加密算法可以描述为如下表达式：Xi+4=F(X1，Xi+1，Xi+2，Xi+3，RKi)=Xi⊕T (Xi+1⊕Xi+2⊕Xi+3⊕RKi), 其中i=0,1 , . . . , 31，代码如下图所示：

![图片5（1）](https://user-images.githubusercontent.com/109191115/181291664-d34624fe-363a-4117-95f6-44b69af35678.png)

其中，非线性变换过S盒，和密钥一样：

![图片5（2）](https://user-images.githubusercontent.com/109191115/181291785-1c1f067b-c434-463d-a8ec-cdca86995065.png)
 
对于线性变换，我们设L的输入为字B，输出为字C，则可得C=L(B)=B⊕(B<<<2)⊕(B<<<10)⊕(B<<<18)⊕(B<<<24)：

![图片5（3）](https://user-images.githubusercontent.com/109191115/181292284-97bb9f2d-92e8-4255-935d-ab5e0598fe87.png)

在加密算法之后，我们还需要一个反序处理R：R(Y0，Y1，Y2，Y3)=(X35，X34，X33，X32) R(Y_0，Y_1，Y_2，Y_3) = (X_{35}，X_{34}，X_{33}，X_{32})，代码如下图所示：

![图片5（4）](https://user-images.githubusercontent.com/109191115/181292327-aabc734a-68a3-442a-8029-32be01aa84a2.png)

*（注：这里直接反向输出即可）*

优化部分如下：
-
我们将加密函数单独提取出来，把32次循环能合并的进行合并，并减少一些参数，循环展开unroll，两次循环都进行展开，并添加流水线，对数组进行分割，代码如下图所示：

![图片6](https://user-images.githubusercontent.com/109191115/181293111-b67801b4-63a4-429b-b16a-cdc56e6f20f5.png)

主函数处也同样，输入输出处循环展开，将能合并的循环进行合并，代码如下图所示：

![图片7](https://user-images.githubusercontent.com/109191115/181293207-eb99ca6b-f2e6-4807-921c-c09b9bf3b6cb.png)
 
实验结果：
=
最后得到结果如下：
-
![图片8](https://user-images.githubusercontent.com/109191115/181293500-163e0147-4aa0-4791-abec-e3389e3f642e.png)

**延迟为：126**
